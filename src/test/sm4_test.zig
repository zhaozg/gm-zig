const std = @import("std");
const sm4 = @import("../sm4.zig");
const SM4 = sm4.SM4;

// Test vectors (GB/T 32907-2016)
test "SM4 Known Answer Test" {
    const key = [16]u8{
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    };
    const plaintext = [16]u8{
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    };
    const expected_ciphertext = [16]u8{
        0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e,
        0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46,
    };

    const ctx = SM4.init(&key);

    // Test single block encryption
    var ciphertext: [16]u8 = undefined;
    ctx.encryptBlock(&plaintext, &ciphertext);
    try std.testing.expectEqualSlices(u8, &expected_ciphertext, &ciphertext);

    // Test single block decryption
    var decrypted: [16]u8 = undefined;
    ctx.decryptBlock(&ciphertext, &decrypted);
    try std.testing.expectEqualSlices(u8, &plaintext, &decrypted);
}

// ECB mode tests
test "SM4-ECB mode encryption and decryption" {
    const key = [16]u8{
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    };
    
    const plaintext = [32]u8{
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
        0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11,
        0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
    };

    const ctx = sm4.SM4_ECB.init(&key);

    var ciphertext: [32]u8 = undefined;
    ctx.encrypt(&plaintext, &ciphertext);

    var decrypted: [32]u8 = undefined;
    ctx.decrypt(&ciphertext, &decrypted);

    try std.testing.expectEqualSlices(u8, &plaintext, &decrypted);
}

// CBC mode tests
test "SM4-CBC mode encryption and decryption" {
    const key = [16]u8{
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    };
    
    const iv = [16]u8{
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
    };

    const plaintext = [32]u8{
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
        0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11,
        0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
    };

    var ctx = sm4.SM4_CBC.init(&key, &iv);

    var ciphertext: [32]u8 = undefined;
    ctx.encrypt(&plaintext, &ciphertext);

    // Reset IV for decryption
    ctx = sm4.SM4_CBC.init(&key, &iv);
    
    var decrypted: [32]u8 = undefined;
    ctx.decrypt(&ciphertext, &decrypted);

    try std.testing.expectEqualSlices(u8, &plaintext, &decrypted);
}

// CTR mode tests
test "SM4-CTR mode encryption and decryption" {
    const key = [16]u8{
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    };
    
    const nonce = [16]u8{
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff,
    };

    const plaintext = [35]u8{ // Non-block-aligned length to test
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
        0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11,
        0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
        0x11, 0x22, 0x33,
    };

    var ctx = sm4.SM4_CTR.init(&key, &nonce);

    var ciphertext: [35]u8 = undefined;
    ctx.encrypt(&plaintext, &ciphertext);

    // Reset counter for decryption
    ctx = sm4.SM4_CTR.init(&key, &nonce);
    
    var decrypted: [35]u8 = undefined;
    ctx.decrypt(&ciphertext, &decrypted);

    try std.testing.expectEqualSlices(u8, &plaintext, &decrypted);
}

// GCM mode tests
test "SM4-GCM mode encryption and decryption" {
    const key = [16]u8{
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    };
    
    const nonce = [12]u8{
        0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
        0x88, 0x99, 0xaa, 0xbb,
    };

    const plaintext = [32]u8{
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
        0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11,
        0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
    };

    const additional_data = [8]u8{
        0xde, 0xad, 0xbe, 0xef, 0xca, 0xfe, 0xba, 0xbe,
    };

    const ctx = sm4.SM4_GCM.init(&key);

    var ciphertext: [32]u8 = undefined;
    var tag: [16]u8 = undefined;
    ctx.encrypt(&nonce, &plaintext, &additional_data, &ciphertext, &tag);

    var decrypted: [32]u8 = undefined;
    const valid = ctx.decrypt(&nonce, &ciphertext, &additional_data, &tag, &decrypted);

    try std.testing.expect(valid);
    try std.testing.expectEqualSlices(u8, &plaintext, &decrypted);

    // Test with wrong tag
    tag[0] ^= 1; // Corrupt tag
    const invalid = ctx.decrypt(&nonce, &ciphertext, &additional_data, &tag, &decrypted);
    try std.testing.expect(!invalid);
}

// XTS mode tests
test "SM4-XTS mode encryption and decryption" {
    const key = [32]u8{
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
        0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88,
        0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00,
    };

    const plaintext = [48]u8{
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
        0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11,
        0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
        0x12, 0x34, 0x56, 0x78, 0x9a, 0xbc, 0xde, 0xf0,
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    };

    const tweak_value: u64 = 12345;

    const ctx = sm4.SM4_XTS.init(&key);

    var ciphertext: [48]u8 = undefined;
    ctx.encrypt(tweak_value, &plaintext, &ciphertext);

    var decrypted: [48]u8 = undefined;
    ctx.decrypt(tweak_value, &ciphertext, &decrypted);

    try std.testing.expectEqualSlices(u8, &plaintext, &decrypted);
}

// Performance comparison test
test "SM4 optimization verification" {
    const key = [16]u8{
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    };
    
    const plaintext = [16]u8{
        0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    };

    const ctx = SM4.init(&key);

    // Test that optimized version produces same results
    var ciphertext: [16]u8 = undefined;
    ctx.encryptBlock(&plaintext, &ciphertext);
    
    // Expected result from standard test vector
    const expected = [16]u8{
        0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e,
        0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46,
    };
    
    try std.testing.expectEqualSlices(u8, &expected, &ciphertext);
}

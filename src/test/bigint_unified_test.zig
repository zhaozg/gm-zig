const std = @import("std");
const testing = std.testing;

// Since this is a demo, we'll test the unified concept without the actual import
// In practice, this would import the unified module
const BigInt = [32]u8;
const BigIntError = error{ InvalidModulus, NotInvertible, Overflow };

// Mock unified functions for demonstration
fn mockMulMod(a: BigInt, b: BigInt, m: BigInt, comptime safe_mode: bool) BigIntError!BigInt {
    _ = safe_mode;
    if (std.mem.allEqual(u8, &m, 0)) return BigIntError.InvalidModulus;
    
    // Simple mock: (a[31] * b[31]) mod m[31] in the last byte
    const result_byte = (a[31] * b[31]) % @max(m[31], 1);
    var result = [_]u8{0} ** 32;
    result[31] = result_byte;
    return result;
}

fn mockAddMod(a: BigInt, b: BigInt, m: BigInt, comptime safe_mode: bool) BigIntError!BigInt {
    _ = safe_mode;
    if (std.mem.allEqual(u8, &m, 0)) return BigIntError.InvalidModulus;
    
    // Simple mock: (a[31] + b[31]) mod m[31] in the last byte
    const result_byte = (a[31] + b[31]) % @max(m[31], 1);
    var result = [_]u8{0} ** 32;
    result[31] = result_byte;
    return result;
}

test "Unified BigInt Concept - Safe vs Fast Mode" {
    const a = [32]u8{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03 }; // 3
    
    const b = [32]u8{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04 }; // 4
    
    const m = [32]u8{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0D }; // 13

    // Test with safe mode (compile-time configuration)
    const safe_result = try mockMulMod(a, b, m, true);
    
    // Test with fast mode  
    const fast_result = try mockMulMod(a, b, m, false);
    
    // Results should be the same in this mock
    try testing.expect(std.mem.eql(u8, &safe_result, &fast_result));
    
    // Mock result: 3 * 4 = 12, which is correct for 12 mod 13 = 12
    try testing.expect(safe_result[31] == 12);
}

test "Unified BigInt Concept - Error Consistency" {
    const zero = [_]u8{0} ** 32;
    const one = [32]u8{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 }; // 1

    // Test invalid modulus errors in both modes
    const safe_error = mockMulMod(one, one, zero, true);
    const fast_error = mockMulMod(one, one, zero, false);
    
    try testing.expectError(BigIntError.InvalidModulus, safe_error);
    try testing.expectError(BigIntError.InvalidModulus, fast_error);
}

test "Unified BigInt Concept - Addition Operations" {
    const a = [32]u8{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x05 }; // 5
    
    const b = [32]u8{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07 }; // 7
    
    const m = [32]u8{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0B }; // 11

    const result = try mockAddMod(a, b, m, true);
    
    // Mock result: (5 + 7) mod 11 = 12 mod 11 = 1
    try testing.expect(result[31] == 1);
}
# wasm

WebAssembly (WASM) 中的 WASI 和 `freestanding` 目标环境。它们代表了 WASM 模块与外部世界交互的两种**根本不同**的方式。

## 核心概念简述

1.  **WebAssembly (WASM):** 一种可移植、体积小、加载快且安全的二进制指令格式，设计目标是在 Web 上实现高性能应用，但也广泛用于非 Web 环境（服务端、边缘计算、插件系统等）。
2.  **执行环境/宿主 (Host Environment):** 运行 WASM 模块的程序或环境（如 Web 浏览器、Node.js、Wasmtime, Wasmer, 边缘计算平台等）。宿主负责提供 WASM 模块运行所需的资源（内存、CPU）和访问外部世界（文件、网络、时间等）的能力。
3.  **系统调用 (System Call / Syscall):** 程序向操作系统内核请求服务的标准方式（如打开文件、读写数据、创建进程、获取时间等）。在传统原生程序中，编译器会将这些高级语言函数调用转换为特定的机器指令序列来触发 syscall。

## WASI (WebAssembly System Interface)

1.  **定义：** **WASI 是一个标准化的 API (应用程序编程接口) 集合。** 它定义了 WASM 模块如何以**安全、可移植、与操作系统无关**的方式访问底层系统资源（文件系统、网络套接字、时钟、随机数生成器、环境变量等）。
2.  **目标：**
    *   **可移植性:** 让同一个编译为 WASI 的 `.wasm` 模块可以在任何实现了 WASI 标准的宿主（如 Wasmtime, Wasmer, Node.js, 浏览器 polyfill）上运行，无需重新编译。
    *   **安全性:** 通过能力导向安全模型 (Capability-based Security) 提供细粒度的资源访问控制。宿主明确授予模块访问特定资源（如特定目录）的“能力”（capability），模块默认没有任何权限。
    *   **非 Web 环境:** 主要解决 WASM 在浏览器之外（服务端、命令行工具等）运行时的系统接口需求。
3.  **工作原理：**
    *   编译器（如 `rustc` 目标 `wasm32-wasi`, `clang` 目标 `wasm32-wasi`）将高级语言（Rust, C/C++ 等）中标准库的函数调用（如 `fopen`, `write`, `gettimeofday`）编译为对 WASI 标准 API (`wasi_snapshot_preview1`) 的调用。
    *   WASM 模块导入（`import`）这些 WASI 函数（如 `fd_write`, `clock_time_get`）。
    *   宿主运行时（如 Wasmtime）在加载模块时，**实现**这些导入的 WASI 函数。宿主将这些 WASI 调用**映射**到宿主所在操作系统的实际系统调用（syscall）上，并根据配置的安全策略（能力）决定是否允许操作。
4.  **关键点:**
    *   **API 标准:** 定义接口规范。
    *   **需要宿主支持:** 模块依赖宿主提供具体的 WASI 实现。
    *   **沙箱化:** 模块运行在宿主严格控制的沙箱环境中，资源访问受限。
    *   **可移植 `.wasm` 文件:** 编译结果是单一的 `.wasm` 文件，目标环境是 `wasm32-wasi`。

## Freestanding (或 Bare Metal / `wasm32-unknown-unknown`)

1.  **定义：** `freestanding`（或 `wasm32-unknown-unknown` 目标）**不是一个像 WASI 那样的 API 标准，而是一种编译目标模式**。它表示编译出的 WASM 模块**不依赖任何特定的操作系统接口或标准库**。
2.  **目标:**
    *   **最低限度依赖:** 生成绝对最小、自包含的 WASM 模块，仅依赖 WASM 核心规范本身（线性内存、基本指令）。
    *   **完全控制:** 开发者对模块如何与宿主交互拥有完全的控制权。没有预设的 API 约束。
    *   **定制交互:** 适用于需要与宿主建立**独特、高度定制化通信协议**的场景（例如：特定游戏引擎插件、区块链智能合约、专有嵌入式环境）。
3.  **工作原理：**
    *   编译器（如 `rustc` 目标 `wasm32-unknown-unknown`, `emcc -s STANDALONE_WASM`）**不会**链接任何标准库（如 libc）或系统接口实现。
    *   生成的 WASM 模块**没有**预定义的导入（`import`）。它只包含开发者显式编写的代码。
    *   所有与外部世界的交互必须通过**自定义导入/导出函数**或**共享内存**来实现：
        *   **自定义导入 (`import`):** 模块声明需要宿主提供的函数。宿主在实例化模块时，必须提供这些具体函数的实现。这些函数做什么、参数是什么、返回值是什么，完全由开发者和宿主约定。宿主可以在这些函数内部做任何事情，包括调用系统调用。
        *   **导出 (`export`):** 模块提供函数给宿主调用（通常是入口点 `_start` 或类似）。
        *   **共享内存:** 模块和宿主可以通过读写同一块线性内存区域来交换复杂数据。
4.  **关键点:**
    *   **编译目标模式:** 一种构建方式。
    *   **无标准库/OS依赖:** 生成的模块极度精简。
    *   **完全自定义交互:** 交互协议（导入/导出函数签名、内存布局）由开发者和宿主环境**双方约定**。
    *   **宿主责任:** 宿主必须实现模块所需的所有自定义导入函数，这些函数内部可以调用 syscall 或其他宿主功能。
    *   **灵活性高，可移植性低:** 同一个 `.wasm` 模块通常只适用于理解其特定自定义接口的宿主。更换宿主可能需要修改模块或宿主。

## 主要区别总结

| 特性             | WASI                                      | Freestanding (`wasm32-unknown-unknown`)            |
| :--------------- | :---------------------------------------- | :------------------------------------------------- |
| **本质**         | **标准化的系统 API 接口规范**             | **不依赖操作系统/标准库的编译目标模式**            |
| **目标**         | 可移植性、安全性（沙箱）、标准化系统访问  | 最小依赖、完全控制、定制化宿主交互                 |
| **依赖宿主**     | **是** - 需要宿主实现 WASI API            | **是** - 需要宿主实现**自定义**的导入函数          |
| **标准库支持**   | 有 (通过 WASI 实现 libc 等接口)           | **无** (或极度精简，仅核心语言运行时)             |
| **系统资源访问** | 通过标准化的 WASI API (`fd_write`等)      | **通过宿主提供的自定义导入函数** (内部可调用 syscall) |
| **可移植性**     | **高** - 兼容 WASI 的宿主即可运行相同模块 | **低** - 模块依赖特定宿主实现的定制接口            |
| **安全性模型**   | 能力导向安全 (Capabilities)               | **由宿主和自定义协议决定** (宿主全权负责)          |
| **典型编译目标** | `wasm32-wasi`                             | `wasm32-unknown-unknown`                           |
| **交互方式**     | 导入标准 WASI 函数                        | 导入自定义函数、导出函数、共享内存                 |
| **适用场景**     | 命令行工具、可移植服务端应用、通用插件    | 游戏引擎插件、区块链智能合约、高度定制化嵌入式环境、需要直接内存控制的场景 |


## 类比 (简化)

*   **WASI:** 就像你买了一台符合 **标准电源插头** 和 **标准操作系统API** (如 POSIX) 的电脑。你可以在任何提供标准插座和运行兼容操作系统的房间（宿主）里使用它。电脑通过标准接口（电源插头、USB、HDMI）与房间交互，房间管理员（宿主）控制你能插哪些设备（能力）。
*   **Freestanding:** 就像你从零开始 **自己设计和焊接了一块电路板**。这块板子没有标准接口。为了让它在某个特定设备（宿主）里工作，你需要：
    1.  在电路板上设计**专门的连接点**（自定义导入函数）。
    2.  告诉该设备制造商**这些连接点需要输入什么信号、输出什么信号**（函数签名约定）。
    3.  设备制造商**按你的要求定制一个接口板**来实现这些连接点（宿主实现自定义导入）。
    4.  这块电路板**只能插在你定制的那个特定设备**上。换到另一个设备，除非它也按你的规格定制了接口，否则无法工作。

## 总结

*   使用 **WASI** 当你需要 **可移植性** 和 **标准化、安全的系统访问**。你编译到 `wasm32-wasi`，依赖宿主提供 WASI 实现。
*   使用 **Freestanding** (`wasm32-unknown-unknown`) 当你需要**绝对最小依赖**、**完全控制交互细节**，或者目标环境**不提供/不需要 WASI** 而是有**自定义的宿主接口协议**。你需要自己定义并实现（或与宿主约定）所有的外部交互点。

简单来说：**WASI 定义了“怎么说话”（标准语言），Freestanding 让你“自己发明一种语言”来说话（并与宿主约定好双方都懂这种语言）。**

## run in shell

### build

> zig build -Dtarget=wasm32-wasi

### run

> wasmtime zig-out/bin/gmlib.wasm

## run in explorer

### build

> zig build -Dtarget=wasm32-freestanding

### install wasm

> bun install

### run http server

> bun run server.ts

### explorer

> http://localhost:3000/run.html
